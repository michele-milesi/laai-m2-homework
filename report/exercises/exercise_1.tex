\section*{Exercise 1}

\subsection*{Exercise 1.4}
Observe that our model of evaluation allows for combinations whose operators are compound expressions. Use this observation to 
describe the behaviour of the following procedure:

\begin{lstlisting}
(define (a-plus-abs-b a b) 
  ((if (> b 0) + -) a b))
\end{lstlisting}

\paragraph{Solution}
The function \texttt{a-plus-abs-b} defined above takes in input 2 parameters and returns the sum $ a + |b| $. 
The formal parameters of the fuction are \texttt{a} and \texttt{b}, while the body of the fuction is composed by a 
a compound expression. The operator of the expression is a compound expression, indeed, it depends on the value of the
parameter \texttt{b}, in particular, if the value of {b} is greater than zero, then it is performed a sum between the 
operands, while if it is less than or equal to zero, then it is performed a substraction.

When this procedure is called, the formal parameters are substituted by the actual parameters, e.g. when we call the procedure as
follows: \texttt{(a-plus-abs-b 5 2)} all the instances of \texttt{a} in the body of the function are substituted by the value
$ 5 $ and all the instances of \texttt{b} are substituted by $ 2 $ and then the body of the function is evaluated.
Considering that the operator is a compound expression, the interpreter firts evaluates it. 
In particular it is a conditional  expression, so the interpreter evaluates the predicate \texttt{(< b 0)} 
and if the condition is true, then it will evaluate the \textit{consequent}, otherwise it evaluates the \textit{alternative}.
In the previous example, after evaluating the conditional expression the expression become \texttt{(+ 5 2)}.
At this point the interpreter evaluates the \textit{operator}: since it is a primitive procedure, the interpreter evaluates all the 
\textit{operands} and it applies the operator to the \textit{arguments} (i.e. the value of the operands).
In the example above, it simplifies the expression with \texttt{7}.
Now the interpreter cannot do any simplification of the expression, indeed, it has to handle a primitive expression, so 
it does not perform any computation step and it returns the computed value.


\subsection*{Exercise 1.5}
Ben Bitdiddle has invented a test to determine whether the interpreter he is faced with is using applicative-order evaluation 
or normal-order evaluation. He defines the following two procedures:

\begin{lstlisting}
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))
\end{lstlisting}

Then he evaluates the expression

\begin{lstlisting}
(test 0 (p))
\end{lstlisting}

What behaviour will Ben observe with an interpreter that uses applicative-order evaluation? What behaviour will he
observe with an interpreter that uses normal-order evaluation? Explain your answer. (Assume that the evaluation
rule for the special form \texttt{if} is the same whether the interpreter is using normal or applicative order: the predicate 
expression is evaluated first, and the result determines whether to evaluate the consequent or the alternative expression).

\paragraph{Solution}
In applicative-order evaluation, when a procedure is called, the arguments are evaluated first and then applied to the
procedure; while in normal-order evaluation the arguments are not evaluated before the procedure call, but they are evaluated
when the body of the function is evaluated.
In this example, an interpreter which uses applicative-order evaluation first evaluats the arguments, so it evaluates \texttt{0} 
(nothing to do) and \texttt{(p)} which causes a loop, indeed, the procedure \texttt{p} calls itself and it does not terminate.
On the other side, an interpreter which uses normal-order evaluation does not evaluate the arguments before the evaluation of
the body of the function, but it passes them without any computation. In this case the procedure call \texttt{(test 0 (p))}
returns the value \texttt{0}, indeed, the interpreter evaluates the conditional expression and, since the formal parameter \texttt{x}
is substituted by the value \texttt{0}, the condition is true and the consequent (i.e. \texttt{0}) is returned.

We can observe that the applicative-order evaluation can be useful when the computation of the arguments is heavy and the arguments are
used many times in the body of the function, but some arguments can be evaluated even if they are not used and this can cause,
as in this particular case, some problems.
Instead, normal-order evaluation can be useful when the are used few times or not used, but if they are used many times and their
computation is heavy, then the performances are worse than applicative-order evaluation.