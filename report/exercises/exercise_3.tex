\section*{Exercise 3}

\subsection*{Exercise 3.2}
Explain why (in terms of the evaluation process) these two programs give different answers 
(i.e. have different distributions on return values):
\begin{lstlisting}
(define foo (flip))
(list foo foo foo)
\end{lstlisting}

\begin{lstlisting}
(define (foo) (flip))
(list (foo) (foo) (foo))
\end{lstlisting}    

\paragraph{Solution} 
In the first program we are defining \texttt{foo} as a variable and we are assigning it the value of the evaluation of the 
expression \texttt{(flip)}, indeed, the value of \texttt{foo} is either \texttt{\#t} or \texttt{\#f}.
After that we create a list which contains three time the value of \texttt{foo}, so if \texttt{foo} has value \texttt{\#t}, then
we are defining a the list: \texttt{'(\#t \#t \#t)}; otherwise we are creating the list: \texttt{'(\#f \#f \#f)}.

In the second program, we are defining a new procedure \texttt{foo} which is a wrapper for the procedure \texttt{flip}. This means
that each time the procedure \texttt{foo} is called, also the procedure \texttt{flip} is called.
For this reason, when we define the list, the expression \texttt{flip} is evaluated three times and, since it is a non-deterministic 
procedure, the three elements of the list can be different.


\subsection*{Exercise 3.5}
Here is a modified version of the tug of war game. Instead of drawing strength from the continuous Gaussian 
distribution, strength is either 5 or 10 with equal probability. Also the probability of laziness is changed from 1/4 to 1/3. 
Here are four expressions you could evaluate using this modified model:

\begin{lstlisting}
(define strength (mem (lambda (person) (if (flip) 5 10))))
(define lazy (lambda (person) (flip (/ 1 3))))
    
(define (total-pulling team)
  (sum
   (map (lambda (person) (if (lazy person)
                             (/ (strength person) 2)
                             (strength person)))
        team)))
    
(define (winner team1 team2)
  (if (< (total-pulling team1) (total-pulling team2))
      team2
      team1))
    
(winner '(alice) '(bob))                        ;; expression 1
    
(equal? '(alice) (winner '(alice) '(bob)))      ;; expression 2
    
(and (equal? '(alice) (winner '(alice) '(bob))) ;; expression 3
     (equal? '(alice) (winner '(alice) '(fred))))
    
(and (equal? '(alice) (winner '(alice) '(bob))) ;; expression 4
     (equal? '(jane) (winner '(jane) '(fred))))
\end{lstlisting}

\begin{itemize}
    \item[a.] Write down the sequence of expression evaluations and random choices that will be made in evaluating each expression.
    \item[b.] Directly compute the probability for each possible return value from each expression.
    \item[c.] Why are the probabilities different for the last two? Explain both in terms of the probability calculations 
        you did and in terms of the “causal” process of evaluating and making random choices.
\end{itemize}

\paragraph{Solution}
\begin{itemize}
    \item[a.] First of all, the procedures are defined and the interpreter associates the name of the procedures with their definition
        in the \textit{global environment}.
        Then the \textit{expression 1} is evaluated: the first step is to retrieve the body of the procedure \texttt{winner} and
        then the formal parameters are substituted by the actual parameters \texttt{'(alice)} and \texttt{'(bob)}. Now the interpreter
        has to evaluate the following expression:
        \begin{lstlisting}
(if (< (total-pulling '(alice)) (total-pulling '(bob)))
    '(bob)
    '(alice)))  
        \end{lstlisting}
        The following step is to evaluate the conditional expression, so it starts by evaluating the \textit{predicate}: 
        \texttt{(< (total-pulling '(alice)) (total-pulling '(bob)))}. The interpreter has to deal with the primitive predicate
        \texttt{<}, so it needs to evaluate the arguments and than apply the predicate to the evaluated arguments.
        The first argument to evaluate is \texttt{(total-pulling '(alice))}: the body of the procedure \texttt{total-pulling} 
        is retrieved in the \textit{global environment} and it is substituted by the expression, 
        then the actual parameter is applied to the body of the procedure. The expression \texttt{(total-pulling '(alice))} becomes
        as follows:
        \begin{lstlisting}
(sum
 (map (lambda (person) (if (lazy person)
                           (/ (strength person) 2)
                           (strength person)))
      '(alice)))
        \end{lstlisting}
        The procedure \texttt{sum} takes as argument a list of numbers and returns the sum over the elements of the list. In this case
        the argument of the procedure is another expression, so the interpreter has to evaluate the argument and then apply it to the
        procedure \texttt{sum}.
        Now the expression to be evaluated is the following:
        \begin{lstlisting}
(map (lambda (person) (if (lazy person)
                      (/ (strength person) 2)
                      (strength person)))
     '(alice))
        \end{lstlisting}
        The procedure \texttt{map} takes as arguments a \textit{lambda} expression and a list. The procedure applies the
        \textit{lambda} expression to each element of the list and returns the list of the results of the \textit{lambda}
        expression on the elements of the list in input.
        So the first step is to evaluate the \textit{lambda} expression with argument \texttt{'alice}. The resulting expression is
        the body of the \textit{lambda} expression with actual parameter \texttt{'alice}:
        \begin{lstlisting}
(if (lazy 'alice) (/ (strength 'alice) 2) (strength 'alice))
        \end{lstlisting}
        Since the interpreter has to evaluate a conditional expression, the interpreter firsts evaluate the \textit{predicate}.
        To evaluate the call \texttt{(lazy 'alice)}, the interpreter first takes the body of the procedure and then substitutes
        all the occurences of formal parameter by the value of the actual parameter. The resulting expression is:
        \begin{lstlisting}
(flip (/ 1 3))
        \end{lstlisting}
        The procedure \texttt{flip} is a probabilistic procedure, it can take as parameter the probability to return \texttt{\#t}.
        In our case, the interpreter has to evaluate the expression \texttt{(/ 1 3)} and than apply the result to the procedure 
        \texttt{flip}.
        We suppose that the result of the call \texttt{(flip 1/3)} is \texttt{\#f}, so the result of the evaluation of the
        \textit{predicate} in the conditional expression is \texttt{\#f}. Since the \textit{predicate} is false, the interpreter has
        to evaluate the \textit{alternative} expression \texttt{(strength 'alice)}.
        It is a procedure call, so the interpreter has to retrieve the body of the procedure and then to substitute the formal
        parameter by the actual one.
        The result is that the interpreter now has to evaluate the following expression:
        \begin{lstlisting}
(if (flip) 5 10)
        \end{lstlisting}
        The procedure \texttt{strength} is a particular type of procedure, indeed, it is memoized through the procedure \texttt{mem}.
        This means that the first time the procedure is called, the result of the call is memorized and each time the procedure is
        called with same the same argument, the interpreter does not evaluate the function, but it retireves the already computed
        result in the \textit{global environment}.
        This is the first time that \texttt{(strength 'alice)} is evaluated, so the procedure has to be evaluated in a normal way.
        The body of the procedure is composed by a conditional expression, the procedure \texttt{flip} is evaluated and we suppose
        that the result is \texttt{\#t}, so the procedure \texttt{strength} returns the value $5$.
    \item[b.]
    \item[c.]  
\end{itemize}

\subsection*{Exercise 3.6}
Use the rules of probability, described above, to compute the probability that the geometric distribution 
defined by the following stochastic recursion returns the number 5.

\begin{lstlisting}
(define (geometric p)
  (if (flip p)
      0
      (+ 1 (geometric p))))
\end{lstlisting}

\paragraph{Solution}
The procedure computes the number of consecutive \textit{false} (\texttt{\#f}) results. Since each coin toss (i.e. \texttt{flip}) is 
independent, the probability of getting five consecutive \textit{false} results (and the sixth one \textit{true}) is given by:
\[ P(geometric = 5) = (1 - p)^{5} \cdot p \]
The formula comes from the fact that the probability of getting a \textit{true} value from the procedure \texttt{flip} is given by
$p$, so the probability of getting a \textit{false} value from \texttt{flip} is $ (1 - p) $.
So the procedure \texttt{geometric} computes the number of trials needed to get the first occurence of success (i.e. \texttt{\#t}).
Each trial has the same probability of success $p$.
For this reason the computed probability is equivalent to the geometric distribution with success probability $p$ and with the 
first occurence of success at the sixth trial.

To check the formula, some samples have been generated in order to approximate the probability to get five consecutive 
\textit{false} results. The experiment consists of generating $ 100000 $ samples with probability 
$ P(true) = P(false) = 0.5 $.
The following procedures are defined in order to implement the experiment: \textit{(i)} \texttt{model} is a wrapper for the 
procedure \texttt{geometric}; \textit{(ii)} \texttt{count-5} takes in input the list of samples and returns the number of
occurences which have value $ 5 $.
Then the samples are generated and the statistics are computed.
\begin{lstlisting}[caption={Experiment to approximate the probability of getting the first occurence of success at the sixth trial},
    captionpos=b]
; number of samples we want to generate
(define n-samples 100000)

; model used to generate the samples
(define (model)
  (define p 0.5)
  (geometric p))

; procedure which counts the number of samples with value 5
(define (count-5 l)
  (if (null? l)
      0
      (if (= (car l) 5)
          (+ 1 (count-5 (cdr l)))
          (count-5 (cdr l)))))

; sampling
(define experiment (repeat model n-samples))

; ratio between the number of samples with value 5
; and the total number of samples
(/ (count-5 experiment) n-samples)

; histogram of the results
(hist experiment)
\end{lstlisting}
The probability computed by hand is $ P(geometric = 5) = 0.5^{5} \cdot 0.5 = 0.5^{6} = 0.015625 $, while the probability computed
by the program is $ P_{program}(geometric) = 1569/100000 = 0.01569 $.
The two probabilities are very similar, so we can conclude that the calculation of the probability is correct.
The histogram of the generated samples is shown in Figure~\ref{fig:3-5}.

\begin{figure}[h]
    \centering
    \includegraphics[width=10cm]{images/3.5.png}
    \caption{
        Histogram of geometric experiment: the \textit{x-axis} represents the values generated during the sampling phase; 
        the \textit{y-axis} represents the number of samples which have a specific value.
    }
    \label{fig:3-5}
\end{figure}


\subsection*{Exercise 3.7}
Convert Table~\ref{tab:es3-7} to a compact Racket program.
\begin{table}[h]
    \begin{center}
        \begin{tabular}{ccc}
            \hline
            A & B & P(A, B) \\
            \hline
            F & F & 0.14 \\
            F & T & 0.06 \\
            T & F & 0.4 \\
            T & T & 0.4 \\
            \hline
        \end{tabular}
    \end{center}
    \caption{Probabilities to be computed with a Racket program}
    \label{tab:es3-7}
\end{table}

\noindent Hint: fix the probability of A and then define the probability of B to depend on whether A is true or not. 
Run your Church program and build a histogram to check that you get the correct distribution.

\begin{lstlisting}
(define a ...)
(define b ...)
(list a b)
\end{lstlisting}

\paragraph{Solution}
The \texttt{a-b-model} has been defined as follows:
\begin{lstlisting}[caption={Model to compute the probabilities of A and B}, captionpos=b]
(define (a-b-model)
  (define a
    (flip 0.8))
  (define b
    (if a
        (flip 0.5)
        (flip 0.3)))
  (list a b))
\end{lstlisting}
The model does not contain the \texttt{rejection-sampler} because we do not need to compute a conditional probability.
The \texttt{a-b-model} defines first the variable \texttt{a} which has probability $0.8$ to be \textit{true}:
this probability can be computed by adding the last two rows of the Table~\ref{tab:es3-7}, indeed, the value of \texttt{A} in
the first two rows is \textit{false}, while in the last two is \textit{true}.
Then the probability of the variable \texttt{b} depends on the value of the variable \texttt{a}, indeed, if \texttt{A} is 
\textit{false}, then the probability that \texttt{B} is \textit{true} $ \frac{0.06}{0.06 + 0.14} = 0.3 $; while if
\texttt{A} is \textit{true}, then la probability that \texttt{B} is true is $ 0.5 $.

\begin{figure}[h]
    \centering
    \includegraphics[width=10cm]{images/3.7.png}
    \caption{
        Histogram of A-B experiment: the \textit{x-axis} represents the values generated during the sampling phase; 
        the \textit{y-axis} represents the number of samples which have a specific value.
    }
    \label{fig:3-7}
\end{figure}

The experiment consists of generating $100000$ samples, the histogram of generated samples is shown in Figure~\ref{fig:3-7}.
It is possible to observe that the samples are distributed as the probability distribution defined in Table~\ref{tab:es3-7},
indeed, the number of samples with value false both for the variable \texttt{A} and \texttt{B} is about $14000$; the number of
samples with \texttt{A} \textit{true} is about $6000$ and the number of samples with value \textit{(true, false)} and 
\textit{(true, true)} is about $40000$ each. 
The number of samples is not exact because we are approximating the probability distribution by sampling.